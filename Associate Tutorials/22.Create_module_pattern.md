# Terraform Module Creation – Recommended Pattern (Summary Notes)

## Goal
Design **composable, sharable, reusable** Terraform modules that lower the barrier for consumers and enforce consistency across teams. Apply coding best practices (clarity, DRY, versioning, docs).

---

## 1) Module Creation Workflow
1. **Find an early adopter team** → gather requirements and pain points.
2. **Scope into modules** (small, opinionated, single responsibility).
3. Build a **Module MVP** → iterate with feedback; publish versions.
4. **Promote consumption** (docs, examples, private registry); improve via collaboration.

---

## 2) Scoping Principles (What belongs in a module?)
- **Encapsulation**: Group resources that are *always deployed together* and tightly coupled.
- **Privilege boundaries**: Keep resources within the same ownership/RBAC boundary in the same module (e.g., networking vs. app).
- **Volatility**: Separate **long‑lived** (DB, routing, IAM) from **change‑prone** (ASGs, app code AMIs) to reduce churn and blast radius.

> If a module’s purpose is hard to explain in one sentence, it’s likely too large.

---

## 3) MVP Guidelines
- Target **~80% of use cases**; avoid edge cases initially.
- Keep scope **narrow**; avoid branching logic/conditionals in v1.
- Expose **only the most commonly modified inputs** as variables.
- **Maximize outputs** (document them). Outputs enable composition across modules/workspaces.

---

## 4) Example Scoping (3‑tier app on AWS)
- **Network module**: VPC, subnets, NACLs, NAT, peering/DC — *high privilege, low change*.
- **Web module**: LB + ASG (+ AMI for web code, SGs, logging) — *tightly scoped to web, high change rate*.
- **App module**: LB + ASG + S3 (app artifacts), SGs, logging — *tightly scoped to app, high change rate*.
- **Database module**: RDS, storage, backups, logging — *high privilege, low change*.
- **Routing module**: Hosted zones, Route 53, route tables — *high privilege, low change*.
- **Security module**: IAM (+ optional SGs/MFA) — *high privilege, low change*.

> Producers publish modules to a **private registry**; consumer teams compose them in root configs. Version everything.

---

## 5) Nesting Modules (Child/Submodules) — Use, but with care
**General rules**
- Document inputs/outputs/behavior clearly.
- Keep **primary module nesting ≤ 2** levels deep (utility/“tags” modules may be an exception).
- Use consistent **variable/output names** across modules.
- Remember that variables/outputs must be defined in both parent and nested modules (avoid redundancy where possible).

**External (child) modules**
- Centrally managed & versioned (e.g., Terraform Registry).  
- Pin versions; changes may impact parents **without code changes** in the parent.  
- Strive for **backward compatibility**; if breaking, document required parent updates.

**Submodules (embedded directories)**
```
root-module/
├── README.md
├── main.tf
└── ec2-instances/   # submodule
    └── main.tf
```
- Versioned **with** the parent; changes validated together.  
- Not directly reusable by other repos → potential duplication.

---

## 6) Naming & Documentation Conventions
**Module naming**
```
terraform-<PROVIDER>-<FUNCTION>
e.g., terraform-aws-network, terraform-azure-database
```

**Variables**
- Human‑readable, explicit; no ambiguous abbreviations.
- **Required inputs**: no defaults (e.g., `var.vpc_id`).
- **Optional inputs**: sensible defaults; document defaults.

**Outputs**
- List all outputs; provide user‑friendly descriptions and formats.

**README.md should include**
- Purpose & architecture scope (one clear sentence).
- Inputs (required/optional, types, defaults).  
- Outputs (names, types, usage examples).  
- Usage examples (copy‑pasteable `module` block).  
- Version compatibility (Terraform & providers).  
- Changelog / upgrade notes (link).

---

## 7) Standard Structure & Repo Hygiene
**Baseline files**
```
main.tf        # resources + module wiring
variables.tf   # inputs
outputs.tf     # outputs
README.md      # docs
LICENSE        # license
examples/      # runnable examples (recommended)
```
**.gitignore** should exclude: `.terraform/`, `terraform.tfstate*`, `*.tfvars` (unless examples), local build artifacts.

**Examples**
- Provide `examples/complete`, `examples/minimal`, etc., with `terraform.tfvars.example` to demonstrate usage.

---

## 8) Collaboration Practices
- Roadmap per module; collect & prioritize consumer requirements.
- Encourage PRs; adopt internal **open‑source** model (contrib guide, CODEOWNERS).
- Assign module **owners**; review changes via **pull requests**.
- Keep a **CHANGELOG**; use semantic versioning (pin in consumers).

---

## 9) Source Control & Publishing
- Each module in its own repo; use **tags** (recommended) or branch‑based releases.
- Publish to **Private Registry** (HCP Terraform/Terraform Enterprise) for discoverability.  
- Validate modules in CI before publishing.

---

## 10) Consumption Workflow (for teams using modules)
1. Discover in **private registry** (search/filter), read README and inputs/outputs.
2. Pin provider & **module versions** in root config.
3. Compose multiple modules; wire with outputs → inputs.
4. Use **workspaces**/directories for environments; avoid cross‑env coupling.
5. Enforce policy with **Sentinel/OPA** (e.g., allow‑only private registry modules).

**Tooling that helps**
- **Private registry**: searchable catalog, versioned modules.
- **Configuration designer/UI** (Terraform Enterprise): interactive module wiring, autocompletes variables & maps outputs.
- **RBAC** per repo: devolved security; networking team owns network module, etc.

---

## 11) Quick Checklist (print‑friendly)
- [ ] Single, clear purpose; small scope; ≤2‑level nesting.
- [ ] Inputs: required vs optional with sensible defaults; typed & documented.
- [ ] Outputs: exhaustive and documented.
- [ ] README with usage examples + compatibility matrix.
- [ ] Semantic versioning; changelog; owner; CI checks.
- [ ] Examples directory with runnable samples.
- [ ] Registry publishing (private/public) and discoverability.
- [ ] Policy & RBAC aligned with privilege boundaries.
- [ ] Separate volatile vs long‑lived resources across modules.

---

## 12) Key Takeaways
- Start **small & opinionated**; iterate with an early adopter.
- Design around **encapsulation, privilege, volatility** boundaries.
- Favor **simple MVPs**, **max outputs**, and **consistent naming/docs**.
- Publish, version, and **collaborate**—treat modules like productized code.
