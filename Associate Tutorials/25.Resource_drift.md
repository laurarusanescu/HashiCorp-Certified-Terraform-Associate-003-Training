# Terraform: Manage Resource Drift — Summary Notes

## Overview
Terraform’s **state file** tracks the current configuration of your infrastructure. When resources are changed outside of Terraform (via console, CLI, etc.), your **state drifts** from reality. Drift can cause Terraform to plan destructive or unintended actions. This tutorial demonstrates how to **detect**, **review**, and **fix** drift safely.

---

## 1. Understanding Drift
- **Drift** occurs when real-world infrastructure differs from what Terraform’s state and configuration describe.
- Causes include:
  - Manual changes via AWS Console or CLI
  - Provider bugs or failed applies
  - Untracked external changes

**Consequences:**
- Terraform might destroy/recreate resources unintentionally to restore its expected state.

---

## 2. Example Setup
Clone the example repo and create infrastructure:

```bash
git clone https://github.com/hashicorp-education/learn-terraform-drift-management
cd learn-terraform-drift-management

ssh-keygen -t rsa -C "your_email@example.com" -f ./key
terraform init
terraform apply
```

**Creates:**
- An EC2 instance (`aws_instance.example`)
- A security group for SSH (`aws_security_group.sg_ssh`)
- An AWS key pair

Verify managed resources:
```bash
terraform state list
# data.aws_ami.ubuntu
# aws_instance.example
# aws_key_pair.deployer
# aws_security_group.sg_ssh
```

---

## 3. Introduce Drift (Outside Terraform)
Manually modify the infrastructure using AWS CLI:

```bash
# Create new security group (port 8080)
export SG_ID=$(aws ec2 create-security-group --group-name "sg_web" --description "allow 8080" --output text)

# Add ingress rule
aws ec2 authorize-security-group-ingress --group-name "sg_web" --protocol tcp --port 8080 --cidr 0.0.0.0/0

# Attach this group to the EC2 instance (removes SSH SG)
aws ec2 modify-instance-attribute --instance-id $(terraform output -raw instance_id) --groups $SG_ID
```
Terraform’s state still expects the old SSH SG — drift is now present.

---

## 4. Detect Drift with a Refresh-Only Plan
Run:
```bash
terraform plan -refresh-only
```

Terraform compares actual infra with the state file and outputs differences **without applying changes**.

Example output:
```
Note: Objects have changed outside of Terraform

~ vpc_security_group_ids = [
  + "sg-0226a51361bf1497a",
  - "sg-0b318a348a4a4e391"
]
```
Terraform detects the new SG and the missing old one.

> ✅ **-refresh-only** is preferred over the old `terraform refresh` command—it previews changes safely.

Apply to sync **state** (not infra):
```bash
terraform apply -refresh-only
```
Now your **state file matches reality**, but your **config** doesn’t (still missing sg_web).

---

## 5. Fix Configuration to Match Reality
Update `main.tf` to define the manually created SG and attach both groups to the instance.

```hcl
resource "aws_security_group" "sg_web" {
  name        = "sg_web"
  description = "allow 8080"
}

resource "aws_security_group_rule" "sg_web" {
  type              = "ingress"
  from_port         = 8080
  to_port           = 8080
  protocol          = "tcp"
  cidr_blocks       = ["0.0.0.0/0"]
  security_group_id = aws_security_group.sg_web.id
}

resource "aws_instance" "example" {
  ami                    = data.aws_ami.ubuntu.id
  key_name               = aws_key_pair.deployer.key_name
  instance_type          = "t2.micro"
  vpc_security_group_ids = [aws_security_group.sg_ssh.id, aws_security_group.sg_web.id]
  tags = {
    Name          = "terraform-learn-state-ec2"
    drift_example = "v1"
  }
}
```

---

## 6. Import Manually Created Resources
Bring `sg_web` and its rule under Terraform management:

```bash
terraform import aws_security_group.sg_web $SG_ID
terraform import aws_security_group_rule.sg_web "$SG_ID"_ingress_tcp_8080_8080_0.0.0.0/0
```
Verify:
```bash
terraform state list
# includes aws_security_group.sg_web and aws_security_group_rule.sg_web
```

---

## 7. Reconcile Infrastructure
Run a full apply to align state, config, and actual infra:
```bash
terraform apply
```
Terraform reattaches the original SSH SG (`sg_ssh`) while retaining the web SG (`sg_web`):
```
~ update in-place
~ vpc_security_group_ids = [
  + "sg_ssh",
  + "sg_web"
]
```

After apply:
- Instance allows **SSH (port 22)** and **HTTP (port 8080)**.

Test:
```bash
ssh ubuntu@$(terraform output -raw public_ip) -i key
curl $(terraform output -raw public_ip):8080
# Hello, World
```

---

## 8. Clean Up
Destroy all resources:
```bash
terraform destroy
```

---

## 9. Key Commands for Drift Management

| Command | Description |
|----------|--------------|
| `terraform plan -refresh-only` | Detect drift without modifying infra |
| `terraform apply -refresh-only` | Update state to match actual infra |
| `terraform import <addr> <id>` | Add unmanaged infra into state |
| `terraform refresh` *(deprecated)* | Force update of state file (modifies immediately) |
| `terraform destroy` | Clean up all managed resources |

---

## 10. Best Practices for Drift Management
✅ **Do**
- Use `-refresh-only` to inspect drift safely.
- Bring external changes under management via `terraform import`.
- Keep your Terraform code as the **source of truth**.
- Use automation/CI pipelines to prevent manual infra edits.

❌ **Avoid**
- Manual infrastructure edits (they cause drift).
- Using `terraform refresh` directly—it overwrites state silently.
- Ignoring drift—it can cause unexpected resource destruction later.

---

## 11. Key Takeaways
- Drift = mismatch between **state/config** and **real infra**.
- Use **`plan -refresh-only`** to detect, **`apply -refresh-only`** to sync state safely.
- Use **`terraform import`** to re-manage externally created resources.
- Keep Terraform as the single source of truth to avoid drift recurrence.

---

**Next Steps:**
- Learn **configuration-driven imports** (Terraform 1.5+).  
- Review:  
  - [Terraform Refresh Docs](https://developer.hashicorp.com/terraform/cli/commands/refresh)  
  - [Refresh-Only Planning Docs](https://developer.hashicorp.com/terraform/cli/run/refresh-only)  
  - HashiCorp Blog: *State of Infrastructure Drift*  
