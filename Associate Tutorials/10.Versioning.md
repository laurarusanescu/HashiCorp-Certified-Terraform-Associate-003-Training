# Summary Notes: Managing Terraform Versions (`required_version`)

## Why version-pin Terraform?
- HashiCorp releases frequently; pinning via **`required_version`** keeps runs **predictable** and prevents accidental upgrades.
- The CLI **refuses to run** when your local version is outside the allowed range.

---

## Typical Workflow
1) **Check current CLI version**
   ```bash
   terraform version
   # Terraform v1.7.5 (for example)
   ```
2) **Update your config** (`terraform.tf`) to allow that version:
   ```hcl
   terraform {
     required_providers {
       aws    = { version = "~> 5.52.0" }
       random = { version = "~> 3.6.2" }
     }
     required_version = "~> 1.7.5"
   }
   ```
3) **Initialize**
   ```bash
   terraform init
   ```
   - Downloads provider versions matching constraints.
   - Writes **`.terraform.lock.hcl`** (commit this file).

4) **Plan & Apply**
   ```bash
   terraform apply
   ```
   - Creates resources and **records** Terraform/core version in state.

---

## If versions don’t match
- Example error (local CLI too **new** for config):
  > *Unsupported Terraform Core version… update the constraint or use a supported CLI version.*
- Fix by editing **`required_version`** to a compatible range (prefer **pessimistic** pinning with `~>`).

---

## State file & versions
- State includes:
  ```json
  {
    "version": 4,
    "terraform_version": "1.7.5"
  }
  ```
- **`version`** (state format) only changes when required by Terraform releases.
- **`terraform_version`** updates whenever you apply with a newer CLI.
- Older CLIs may refuse to operate on state created by newer CLIs:
  > *state snapshot was created by Terraform v1.7.5… upgrade to v1.7.5 or greater*

> Once upgraded to a newer **state format**, there is **no supported downgrade** path.

---

## Providers vs. Terraform core
- Provider versions are **independent** of Terraform version.
- Upgrading Terraform may require **updating providers**.
- Lock and upgrade providers with:
  ```bash
  terraform init -upgrade
  ```
  (See “Lock and Upgrade Provider Versions” tutorial.)

---

## Version constraint patterns (examples)
| Constraint                | Allows                                | Notes |
|--------------------------|----------------------------------------|------|
| `1.7.5`                  | **Only** v1.7.5                        | Exact pin |
| `>= 1.7.5`               | v1.7.5 **and newer** (incl. v2.x)      | Very broad |
| `~> 1.7.5`               | v1.7.5–1.7.x (no 1.8+)                 | Safe patch updates |
| `>= 1.7.5, < 1.9.5`      | Range-bounded                          | Avoid specific minors |

**Best practice:** Pin **major.minor** with `~>` (e.g., `~> 1.7.0`) to allow safe **patch** updates without code changes. Schedule minor/major upgrades deliberately.

---

## Team practices & tips
- **Commit** `.terraform.lock.hcl`; **never commit** state or secret files.
- Document the **required_version** policy in `README.md`.
- Align CI/CD runners and developer machines to the **same CLI version** as enforced by `required_version`.
- After bumping core version, run `terraform init` and verify `plan` is clean.
- If needed, upgrade providers and modules in the same PR and review diffs carefully.

---

## Cleanup (from the tutorial)
```bash
terraform destroy
# confirm: yes
```

---

## TL;DR
Use **`required_version`** to gate which Terraform CLIs can run your configuration, keep the **lock file** in VCS for reproducible provider selection, and upgrade core & providers **intentionally** to avoid surprises.
