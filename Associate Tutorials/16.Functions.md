# Terraform Dynamic Operations with Functions

## Overview
This tutorial explains how to make Terraform configurations more dynamic using built-in functions like `templatefile`, `lookup`, and `file`. You will learn how to generate scripts dynamically, retrieve values from maps, and read file contents for configuration.

---

## Prerequisites
- Terraform v1.2+ installed locally
- AWS account with configured credentials
- Basic familiarity with Terraform workflow

---

## 1. Using `templatefile` Function
The `templatefile` function allows you to dynamically generate files (like EC2 user data scripts) by interpolating variables.

### Example:
```hcl
user_data = templatefile("user_data.tftpl", {
  department = var.user_department,
  name       = var.user_name
})
```
### Template File Example (`user_data.tftpl`):
```bash
#!/bin/bash
sudo apt-get update
sudo apt-get install -y golang-go
sudo groupadd -r ${department}
sudo useradd -m -s /bin/bash ${name}
```
This function makes configuration reusable and adaptable by dynamically inserting variable values.

---

## 2. Using `lookup` Function
The `lookup` function retrieves values from a map based on a specified key. It is useful for region-based configurations such as AMIs.

### Example Variable:
```hcl
variable "aws_amis" {
  type = map
  default = {
    "us-east-1" = "ami-04b70fa74e45c3917"
    "us-west-2" = "ami-08012c0a9ee8e21c4"
    "us-east-2" = "ami-09040d770ffe2224f"
  }
}
```
### Usage:
```hcl
ami = lookup(var.aws_amis, var.aws_region)
```
### Output Example:
```hcl
output "ami_value" {
  value = lookup(var.aws_amis, var.aws_region)
}
```
This helps dynamically select region-specific AMIs without hardcoding them.

---

## 3. Using `file` Function
The `file` function reads the contents of a file and uses them directly in Terraform configurations. It is commonly used to load SSH keys, certificates, or configuration files.

### Example:
```hcl
resource "aws_key_pair" "ssh_key" {
  key_name   = "ssh_key"
  public_key = file("ssh_key.pub")
}
```
This securely loads an SSH public key for your EC2 instance.

---

## 4. Example: Adding SSH Access
You can combine the above functions to create a secure and dynamic infrastructure setup.

### Security Group Example:
```hcl
resource "aws_security_group" "sg_22" {
  name   = "sg_22"
  vpc_id = aws_vpc.vpc.id

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
}
```
### Updated EC2 Resource:
```hcl
resource "aws_instance" "web" {
  ami                    = lookup(var.aws_amis, var.aws_region)
  instance_type          = "t2.micro"
  subnet_id              = aws_subnet.subnet_public.id
  vpc_security_group_ids = [aws_security_group.sg_22.id, aws_security_group.sg_8080.id]
  user_data              = templatefile("user_data.tftpl", { department = var.user_department, name = var.user_name })
  key_name               = aws_key_pair.ssh_key.key_name
}
```
> ⚠️ **Note:** Allowing public SSH access (0.0.0.0/0) is not secure for production environments.

---

## 5. Terraform Workflow Summary
1. **Initialize:** `terraform init`
2. **Plan Changes:** `terraform plan`
3. **Apply Configuration:** `terraform apply`
4. **Verify Outputs:** Access EC2 via browser or SSH
5. **Destroy Resources:** `terraform destroy`

---

## 6. Key Takeaways
- **`templatefile()`**: Dynamically interpolate values in templates.
- **`lookup()`**: Access map elements dynamically.
- **`file()`**: Read and inject file contents into configuration.
- Helps make infrastructure **reusable**, **flexible**, and **less error-prone**.

---

## Next Steps
- Explore [Terraform Functions Documentation](https://developer.hashicorp.com/terraform/language/functions)
- Learn about dynamic expressions using `count` and `for_each`.
- Practice modular Terraform design for scalability.
