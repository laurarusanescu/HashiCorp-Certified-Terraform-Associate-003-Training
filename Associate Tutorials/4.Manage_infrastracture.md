# Summary Notes: Terraform Variables, Outputs, and Modules (AWS EC2)

## What You’ll Learn
- How Terraform **applies changes** to existing infrastructure.
- How to add **input variables** and **outputs** to make configs flexible.
- How to use a **module** (VPC) and wire your EC2 instance into it.
- How Terraform uses a **dependency graph** to order creates/updates/destroys.

---

## Prerequisites
- Terraform CLI ≥ **1.2.0**
- AWS CLI
- AWS account with permissions in **us-west-2**
- Previous tutorial’s project: `learn-terraform-get-started-aws` with:
  - `terraform.tf` (provider + TF version)
  - `main.tf` (EC2 instance + Ubuntu AMI data source)

---

## Starting Point
### `terraform.tf`
```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.92"
    }
  }
  required_version = ">= 1.2"
}
```

### `main.tf`
```hcl
provider "aws" {
  region = "us-west-2"
}

data "aws_ami" "ubuntu" {
  most_recent = true
  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd-gp3/ubuntu-noble-24.04-amd64-server-*"]
  }
  owners = ["099720109477"] # Canonical
}

resource "aws_instance" "app_server" {
  ami           = data.aws_ami.ubuntu.id
  instance_type = "t2.micro"
  tags = { Name = "learn-terraform" }
}
```

---

## 1) Add **Input Variables**
Create `variables.tf`:
```hcl
variable "instance_name" {
  description = "Value of the EC2 instance's Name tag."
  type        = string
  default     = "learn-terraform"
}

variable "instance_type" {
  description = "The EC2 instance's type."
  type        = string
  default     = "t2.micro"
}
```

Update **`main.tf`** to reference variables (avoid duplicates):
```hcl
resource "aws_instance" "app_server" {
  ami           = data.aws_ami.ubuntu.id
  instance_type = var.instance_type

  tags = {
    Name = var.instance_name
  }
}
```

### Override variables at plan/apply time
```bash
terraform plan -var instance_type=t2.large
```
- Shows `~ update in-place` (or replacement) depending on provider behavior.
- For EC2 type change, Terraform **replaces** the instance; some attrs are
  **(known after apply)** because AWS assigns them on creation.

---

## 2) Add an **Output**
Create `outputs.tf`:
```hcl
output "instance_hostname" {
  description = "Private DNS name of the EC2 instance."
  value       = aws_instance.app_server.private_dns
}
```
Apply and view outputs:
```bash
terraform apply
terraform output
```

**Why outputs?** They provide a clean interface for other automation (CI/CD, scripts, downstream modules) to consume runtime values.

---

## 3) Use a **Module** (VPC)
Add the official VPC module to `main.tf`:
```hcl
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.19.0"

  name = "example-vpc"
  cidr = "10.0.0.0/16"

  azs             = ["us-west-2a", "us-west-2b", "us-west-2c"]
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24"]
  public_subnets  = ["10.0.101.0/24"]

  enable_dns_hostnames = true
}
```

Move the instance into the new VPC:
```hcl
resource "aws_instance" "app_server" {
  ami           = data.aws_ami.ubuntu.id
  instance_type = var.instance_type

  vpc_security_group_ids = [module.vpc.default_security_group_id]
  subnet_id              = module.vpc.private_subnets[0]

  tags = { Name = var.instance_name }
}
```

Initialize to install the module:
```bash
terraform init
```

Plan & apply:
```bash
terraform apply
# Expect: VPC + subnets + SG created; EC2 instance replaced
```

List state:
```bash
terraform state list
```
Module-managed resources are addressed like `module.vpc.*`.

---

## How Terraform Applies Changes
- Terraform builds a **dependency graph** across resources/modules.
- Operations run **in dependency order** and **in parallel** where safe.
- Plans reflect actions:
  - `+ create`
  - `~ update in-place`
  - `-/+ destroy and then create replacement` (aka **replace**)

---

## Tips & Good Practices
- Keep `variables.tf` and `outputs.tf` separate for maintainability.
- Use descriptive variable names and types; default values for sane behavior.
- Always **review the plan** before applying.
- Commit `.terraform.lock.hcl` for reproducible provider selections.
- Use outputs to integrate with deployment scripts/CI.

---

## Clean Up (optional)
```bash
terraform destroy
```

---

## Troubleshooting
- **Plan shows replacement:** Check if the provider/API supports in-place updates.
- **AMI data source fails:** Ensure region/filters match available AMIs.
- **Permissions errors:** Verify IAM policies for VPC/EC2/SG/NAT as needed.
