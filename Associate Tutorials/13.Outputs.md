# Terraform Outputs — Quick Cheat Sheet

## Why outputs?
- Expose data from your Terraform run for humans, scripts, other workspaces, or parent/child modules.
- Stored in state; updated when you `apply` (or `plan -out` + `apply tfplan`).

---

## Define outputs (`outputs.tf`)
```hcl
output "vpc_id" {
  description = "ID of project VPC"
  value       = module.vpc.vpc_id
}

output "lb_url" {
  description = "URL of load balancer"
  value       = "http://${module.elb_http.elb_dns_name}/"
}

output "web_server_count" {
  description = "Number of web servers provisioned"
  value       = length(module.ec2_instances.instance_ids)
}
```

> Tip: Always add `description` for clarity.

---

## Make outputs sensitive
```hcl
output "db_username" {
  description = "DB admin user"
  value       = aws_db_instance.database.username
  sensitive   = true
}

output "db_password" {
  description = "DB admin password"
  value       = aws_db_instance.database.password
  sensitive   = true
}
```

### Redaction rules at a glance
| How you read outputs | Sensitive values redacted? |
|---|---|
| `terraform apply/plan/destroy` final output | **Yes** (`<sensitive>`) |
| `terraform output` (all) | **Yes** (redacted) |
| `terraform output NAME` (single) | **No** (value is printed) |
| `terraform output -json` | **No** (raw values in JSON) |
| Terraform state file (`terraform.tfstate`) | **No** — values are **plain text** |

**Security**: Protect state (remote backend with encryption + access controls, e.g., HCP Terraform). Avoid printing single outputs with secrets in CI logs.

---

## Update state so outputs appear
Outputs are stored in state; to (re)compute them:
```bash
terraform apply -auto-approve   # or apply an existing saved plan
```

---

## Query outputs
```bash
terraform output                 # list all (human-readable)
terraform output lb_url          # single output (may reveal sensitive)
terraform output -raw lb_url     # unquoted string for scripts
terraform output -json           # machine-readable for automation
```

**Script example**:
```bash
curl "$(terraform output -raw lb_url)"
```

**JSON example**:
```bash
terraform output -json | jq '.vpc_id.value'
```

---

## Use outputs across modules
- **Child → Root**: define outputs in the child module; reference as `module.child_name.output_name` in the root.
- **Root → Another Workspace (HCP Terraform)**: use _Run Triggers_ or the `tfe`/`terraform` data sources to consume outputs from a producing workspace.

---

## Common patterns
### Combine values with interpolation
```hcl
output "alb_health_check" {
  value = "http://${module.elb_http.elb_dns_name}/healthz"
}
```

### Derived maps/lists for consumers
```hcl
output "service_endpoints" {
  value = {
    web = "https://${module.lb.lb_dns}"
    db  = aws_db_instance.database.address
  }
}
```

### Guard against nulls (e.g., optional resources)
```hcl
output "maybe_bucket" {
  value     = try(aws_s3_bucket.example.id, null)
  sensitive = false
}
```

---

## Best practices
- Keep outputs minimal and purposeful; they are part of your module’s public API.
- Mark anything credential-like as `sensitive = true` **and** secure your state.
- Favor stable formats (strings, numbers, maps/lists of primitives) for consumers.
- Document outputs thoroughly with `description`.
- In CI, avoid `terraform output NAME` for secrets; prefer backend-native secret handling.

---

## Troubleshooting
- **Output not showing?** Ensure you ran `terraform apply` after adding/updating outputs.
- **Wrong value?** Remember outputs reflect **state**, not live resources—refresh/apply to update.
- **Sensitive printed unexpectedly?** Check logs for `terraform output NAME` or `-json` usage; mask in CI.

---

## Quick demo commands (drop-in)
```bash
# After apply
terraform output
terraform output -raw lb_url
terraform output -json | jq
```

---

## Cleanup reminder
Destroy infra when done to avoid costs:
```bash
terraform destroy
```
