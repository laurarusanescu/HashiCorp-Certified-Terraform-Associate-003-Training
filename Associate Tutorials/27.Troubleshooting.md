# Troubleshoot Terraform — Quick Cheat Sheet

> Based on the **“Troubleshoot Terraform”** tutorial. Use this as a fast reference for fixing broken configs, validating, and reporting issues.

---

## 1) The Four Error Layers (start closest to you)
- **Language (HCL)** – Syntax, interpolation, invalid refs. Fix with `terraform fmt` + `terraform validate`.
- **State** – Drift/out-of-sync. Fix via `-refresh-only`, `import`, `apply -replace`, or targeted ops (sparingly).
- **Core (Terraform engine)** – Dependency graph, plan/apply orchestration; rare bugs.
- **Provider** – Auth, API calls, resource schema; version-specific behavior.

---

## 2) Core Workflow for Fixing a Broken Config
1. **Format**: `terraform fmt`  
   - Flags basic parse issues (invalid character/expression).
2. **Initialize**: `terraform init`  
   - Installs providers; creates `.terraform.lock.hcl`.
3. **Validate**: `terraform validate`  
   - Catches semantic errors (cycles, invalid refs, wrong meta-args, etc.).
4. **Plan / Apply** when clean.

---

## 3) Common Issues & Proven Fixes

### A) Variable interpolation / string building
**Problem**: `Name = $var.name-learn` → invalid character/expression  
**Fix**: Use interpolation or template strings.  
```hcl
tags = {
  Name = "${var.name}-learn"
}
```

### B) Dependency cycles (security groups example)
**Problem**: Two SGs each reference the other in inline `ingress` → cycle.  
**Fix**: Define **SGs first**, then add **aws_security_group_rule** resources that link them.
```hcl
resource "aws_security_group" "sg_ping" { name = "Allow Ping" }
resource "aws_security_group" "sg_8080" { 
  name = "Allow 8080"
  egress { from_port = 0 to_port = 0 protocol = "-1" cidr_blocks = ["0.0.0.0/0"] }
}

resource "aws_security_group_rule" "allow_ping" {
  type = "ingress"
  protocol = "icmp"
  from_port = -1
  to_port   = -1
  security_group_id         = aws_security_group.sg_ping.id
  source_security_group_id  = aws_security_group.sg_8080.id
}

resource "aws_security_group_rule" "allow_8080" {
  type = "ingress"
  protocol = "tcp"
  from_port = 8080
  to_port   = 8080
  security_group_id         = aws_security_group.sg_8080.id
  source_security_group_id  = aws_security_group.sg_ping.id
}
```

### C) Wrong collection type with `for_each`
**Problem**: `for_each = aws_security_group.*.id` → splat returns **list**, but `for_each` needs **map**.  
**Fix**: Build a map via `locals` and use `each.value`.
```hcl
locals {
  security_groups = {
    sg_ping = aws_security_group.sg_ping.id
    sg_8080 = aws_security_group.sg_8080.id
  }
}

resource "aws_instance" "web_app" {
  for_each               = local.security_groups
  ami                    = data.aws_ami.ubuntu.id
  instance_type          = "t2.micro"
  vpc_security_group_ids = [each.value]     # not each.id
  user_data              = <<-EOF
    #!/bin/bash
    apt-get update
    apt-get install -y apache2
    sed -i -e 's/80/8080/' /etc/apache2/ports.conf
    echo "Hello World" > /var/www/html/index.html
    systemctl restart apache2
  EOF
  tags = { Name = "${var.name}-learn-${each.key}" }
}
```

### D) Outputs for resources created with `for_each`
**Problem**: `value = aws_instance.web_app.id` → missing instance key.  
**Fix**: Use a **for-expression** to gather values.
```hcl
output "instance_id"        { value = [for i in aws_instance.web_app : i.id] }
output "instance_public_ip" { value = [for i in aws_instance.web_app : i.public_ip] }
output "instance_name"      { value = [for i in aws_instance.web_app : i.tags.Name] }
```

---

## 4) Drift / State-sanity Essentials (brief)
- Detect: `terraform plan -refresh-only` (safe preview of state changes).  
- Adopt unmanaged resource: `terraform import TYPE.NAME ID`.  
- Recreate only one resource: `terraform apply -replace="TYPE.NAME"`.  
- **Avoid** habitual `-target` usage; it’s for recovery only.

---

## 5) Version & Provider Checks
```bash
terraform version
# If needed: update providers in versions and re-run `terraform init -upgrade`
```

---

## 6) Logging for Bug Reports
Enable detailed logs (temp):
```bash
export TF_LOG_CORE=TRACE
export TF_LOG_PROVIDER=TRACE
export TF_LOG_PATH=logs.txt
# run a repro command, e.g.:
terraform refresh
# then inspect logs.txt; unset variables when done
export TF_LOG_CORE=
export TF_LOG_PROVIDER=
```
**Decide where to file**:  
- Core issues → terraform repo issues.  
- Provider issues → the provider’s GitHub repo (from the Registry page).  
Include: versions, minimal repro config, exact cmds + output, relevant logs (trimmed).

---

## 7) Fast Checklist
- [ ] `terraform fmt` → fix syntax/interpolation.  
- [ ] `terraform init` → providers installed/locked.  
- [ ] `terraform validate` → semantic errors/cycles/types.  
- [ ] Fix cycles using standalone `aws_security_group_rule`.  
- [ ] For collections: use **map** for `for_each`; lists for `count`.  
- [ ] Outputs across `for_each`: use `for` expressions.  
- [ ] If drift suspected: `plan -refresh-only` first.  
- [ ] Import/replace targeted resources judiciously.  
- [ ] Capture TRACE logs if reporting.

---

## Handy Commands
```bash
terraform fmt
terraform init
terraform validate
terraform plan
terraform apply
terraform plan -refresh-only
terraform apply -refresh-only
terraform import aws_security_group.sg_web sg-0123456789abcdef0
terraform apply -replace="aws_instance.web_app"
```

---

### Notes
- Use `-target` only to recover from errors or as directed by error messages.
- Keep `.terraform.lock.hcl` in VCS to ensure reproducible provider versions.
- Consider workspaces/dirs for env separation; avoid shared monoliths as infra grows.
