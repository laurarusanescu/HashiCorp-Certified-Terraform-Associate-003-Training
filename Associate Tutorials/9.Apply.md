# Summary Notes: Terraform `apply` — Executing Planned Changes

## Where `apply` fits in the workflow
1) **init** – configures backend; installs providers/modules; creates lock file  
2) **plan** – computes diff between config and current state; optional `-out FILE`  
3) **apply** – **executes** the plan: creates/updates/destroys resources to match config

---

## What `terraform apply` does
- **State lock**: locks the workspace to prevent concurrent writes.
- **Plan**: if no saved plan is provided, creates one and prompts for approval.
- **Execute**: runs steps using initialized providers & modules.
- **Ordering & parallelism**: honors **dependencies** (sequential where required) and runs **in parallel** when safe.
- **State update & unlock**: writes the new state snapshot, then unlocks.
- **Outputs**: prints any outputs from `outputs.tf`.

```bash
terraform apply                 # creates plan, asks to confirm, then executes
terraform apply "saved-plan"    # executes exactly that plan; no confirm prompt
```

---

## Example config (high level)
- Providers: **aws**, **random**, **time** (pinned versions)
- Data source: latest Ubuntu AMI
- Resources:
  - `random_pet.instance` (name seed)
  - `aws_instance.main` (count = 3, t2.micro, tags include random name + index)
  - `aws_s3_bucket.example`
- Result: Terraform creates the random pet and reads AMI first, then provisions **3 EC2 instances** (in parallel) and an **S3 bucket**; prints `bucket_name` output.

---

## Error handling during `apply`
If an apply step **fails**:
- Terraform **logs the error**, **updates state** with any completed changes, **unlocks**, and **exits**.
- There is **no automatic rollback**. Fix the root cause and **re-apply**.

### Demo scenario (induced error)
1) Save a plan adding `aws_s3_object.example` to an existing bucket.
2) **Delete the bucket outside Terraform** (drift).
3) `terraform apply "add-object"` → **fails** (NoSuchBucket).
4) `terraform show` still lists the bucket (state not refreshed).  
5) Run `terraform apply` again → Terraform **refreshes state**, detects missing bucket, and plans **recreate bucket + object**. Approve to fix drift.

> **Key point:** If real-world infra changes after a plan is saved, the plan may no longer be valid. Re‑plan to refresh and reconcile state.

---

## Targeted & Partial Operations
### Force replace an unhealthy resource
```bash
terraform apply -replace="aws_instance.main[1]"
```
- Destroys and recreates that specific instance (no config change required).

### Target specific resources
```bash
terraform apply -target="aws_s3_object.example"
```
- Apply only targeted addresses (use sparingly; can leave infra in partial state).

---

## Security & State
- State contains sensitive data; store securely (consider **remote state** / HCP Terraform).
- Saved plans and JSON plan outputs can include **secrets**. **Never commit** them to VCS.

---

## Useful commands
```bash
terraform init
terraform plan [-out FILE]
terraform apply ["FILE"]             # saved plan executes without prompt
terraform state list                 # addresses for -replace/-target
terraform show [-json]               # inspect state / plans (read-only)
terraform destroy                    # shortcut: destroy plan + apply
```

---

## Troubleshooting checklist
- **Drift** or out-of-date state? → `terraform plan` (refresh) then apply.
- **Provider/API errors** (limits, conflicting names, transient network issues)?
  - Fix externally or adjust config; retry apply.
- **Unhealthy resource**? → `-replace=ADDR`.
- **Need to stage changes**? → Use **saved plans** and promotion through CI/CD.

---

## Takeaways
- `apply` is **idempotent** wrt configuration + state: it moves infra to the **desired state**.
- Terraform handles **ordering** and **parallelism** automatically via the dependency graph.
- On errors, Terraform **does not roll back**; you **re-plan/re-apply** after remediation.
