# Refactor Monolithic Terraform Configuration — Summary Notes

## Overview
Refactor a single-folder, single-state **monolithic Terraform project** into safer, clearer units. You’ll begin with one config that deploys two S3‑hosted web apps (dev & prod), then evolve it through common stages until **each environment has its own configuration and state**.

---

## Why refactor a monolith?
- **Clarity**: Easier to navigate than a huge `main.tf`.
- **Safety**: Fewer unintended cross‑env changes.
- **Ownership & Scale**: Teams can manage environments independently.
- **Change Control**: Review, test, and promote changes more predictably.

---

## Starting point (Monolith)
- One directory, one state file (`terraform.tfstate`), one `main.tf` with both **dev** and **prod** resources:
  - `random_pet` for unique bucket names.
  - Two S3 buckets (dev/prod), website config, ACL, policy.
  - Uploads a local HTML asset via `file()`.
- Variables in `variables.tf`, example values in `terraform.tfvars.example` → rename to `terraform.tfvars`.
- Commands:
  ```bash
  terraform init
  terraform apply
  ```

### Hidden risk: shared dependencies
- Both environments referenced the **same** `random_pet` output. Changing it in one file (e.g., length from 3 → 4) **replaced resources in BOTH** environments.
- **Lesson**: Carefully inspect plans; avoid hidden cross‑env coupling.

---

## Phase 1 — Split config files (still one directory/state)
- Copy `main.tf` → `dev.tf`, rename original to `prod.tf`.
- Remove dev blocks from `prod.tf` and prod blocks from `dev.tf`.
- **Avoid duplicates**: Since Terraform merges all files in a directory, **comment out** one copy of shared blocks to prevent name collisions (e.g., provider, `random_pet`).  
  ```hcl
  /* shared blocks commented out in prod.tf to avoid duplication */
  ```
- **Still risky**: Both files still share **the same state and some definitions**, so unintended coupling may persist.

---

## Phase 2 — Separate states (recommended)
Two common approaches:

### A) **Directories** (shown in tutorial; good for envs that diverge)
Structure:
```
.
├── assets/
│   └── index.html
├── dev/
│   ├── main.tf
│   ├── variables.tf
│   ├── terraform.tfvars
│   └── terraform.tfstate
└── prod/
    ├── main.tf
    ├── variables.tf
    ├── terraform.tfvars
    └── terraform.tfstate
```
Steps:
1. `mkdir dev prod`
2. Move/rename: `dev.tf → dev/main.tf`, `prod.tf → prod/main.tf`  
   Copy supporting files into each directory.
3. Fix asset path (one level up now):
   ```hcl
   content = file("${path.module}/../assets/index.html")
   ```
4. Remove cross‑env references in each env’s `variables.tf`, `outputs.tf`, and `terraform.tfvars`.
5. In **prod/main.tf**, **uncomment** its own provider/`random_pet`/terraform blocks (dev has its own copies too).

Deploy:
```bash
cd dev && terraform init && terraform apply
cd ../prod && terraform init && terraform apply
```
Result: **Isolation by directory** → separate configs and **separate state files**. Smaller blast radius.

**Trade‑offs**:
- ✅ Maximum isolation; can diverge per env.
- ⚠️ Code duplication risk → drift. Consider shared modules to reduce duplication.

### B) **Workspaces** (alternative, not shown step‑by‑step here)
- Same config, multiple states via `terraform workspace`.
- Best when environments **don’t diverge much**. Less duplication, but you must carefully handle per‑env settings (e.g., prefixes).

---

## Cleanup
Destroy each environment **from its own directory**:
```bash
cd dev  && terraform destroy
cd ../prod && terraform destroy
```

---

## Best practices & tips
- **Separate state** per env to avoid accidental cross‑env changes.
- Prefer **directory separation** when envs differ significantly; use **workspaces** for near‑identical envs.
- **Eliminate hidden dependencies** between environments (no shared randoms/locals).
- Keep **provider/terraform blocks** local to each env when isolating by directory.
- Use **modules** to dedupe logic across envs and keep variable inputs explicit.
- Always **review `plan`** output before `apply` (and in CI).
- Store state **remotely** (e.g., HCP Terraform/S3+DynamoDB) for collaboration and locking.

---

## Quick command recap
```bash
# Start
terraform init
terraform apply

# Split configs
cp main.tf dev.tf && mv main.tf prod.tf

# Create directories
mkdir dev prod
mv dev.tf dev/main.tf
mv prod.tf prod/main.tf
cp variables.tf terraform.tfvars outputs.tf dev/
mv variables.tf terraform.tfvars outputs.tf prod/

# Adjust paths in each env's main.tf and remove cross-env refs
# Deploy per env
cd dev  && terraform init && terraform apply
cd ../prod && terraform init && terraform apply

# Cleanup per env
cd dev  && terraform destroy
cd ../prod && terraform destroy
```

---

## Key takeaways
- Monoliths are convenient early; **refactor** as you grow.
- **Separate state** to shrink blast radius and improve safety.
- **Directories vs Workspaces** depends on how much envs differ.
- Use **modules** to share logic and avoid duplication while keeping envs isolated.
